![image](https://user-images.githubusercontent.com/9743418/102427558-8e0f6d80-404c-11eb-8606-e954942e30af.png)

## 前言

### 本文主要内容

- 时间切片概念和原理
- 时间切片的实际使用场景

time-slice 被称为“时间切片”，主要用来解决 js 大量更新视图时耗时操作带来的“掉帧”现象。

## 正文

### 掉帧

我们先从问题现象开始探究——为什么会出现“掉帧”？

众所周知，一般浏览器最差最差刷新频率也需要 60HZ 即每秒 60 帧，肉眼才能直观的感受到是流畅的。出现掉帧也就是一秒钟内刷新频率少于 60 帧，一帧耗时 1000/60 = 16.67ms，也就是说在原本 60 帧的渲染过程中，有几帧的执行耗时超过了 16.67 ms。

那么探究重点当然要归于一帧中的渲染过程，以及我们从中能学到些什么。

### 时间切片原理

由于一帧渲染过程中的 js 操作属于业务型代码，要优化耗时操作可以由业务方手动优化 js 代码。

假设 1 千次简单的 DOM 操作耗时在 16.67ms内，那么业务方将 1万次 DOM 操作用 setTimeout 分 10 次才不会出现掉帧，这样也能达到优化目的。

还有一种办法是由系统调度，因为很多时候并不是每一帧的耗时都是满满的 16.67 ms，或者说根本没有视图更新，不需要触发帧的渲染，这个时候完全可以用来调度执行那些耗时的视图更新。

时间切片技术就是使用了 `requestIdleCallback` 空闲调度函数来实现。

```js
/*
 * didTimeout {boolean} 回调是否由 timeout 参数时间到了正在被执行
 * timeRemaining {() => number} 用来获取当前一帧范围内剩余空闲时间的毫秒数
 * timeout {number} 用来指定回调的超时时间
 */
requestIdleCallback(({ didTimeout, timeRemaining() }) => {}, { timeout })
```

### 一帧的渲染过程

上面所述的 1 万次更新 DOM 的操作，我简单的说利用 setTimeout 可以分 10 次，是否可以认为：一帧就是一次 macro 调度？答案是否定的。

一帧的渲染过程



