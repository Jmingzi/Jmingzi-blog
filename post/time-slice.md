![image](https://user-images.githubusercontent.com/9743418/102427558-8e0f6d80-404c-11eb-8606-e954942e30af.png)

## 前言

### 本文主要内容

- 时间切片概念和原理
- 时间切片的实际使用场景

time-slice 被称为“时间切片”，主要用来解决 js 大量更新视图时耗时操作带来的“掉帧”现象。

## 正文

### 掉帧

我们先从问题现象开始探究——为什么会出现“掉帧”？

众所周知，一般浏览器最差最差刷新频率也需要 60HZ 即每秒 60 帧，肉眼才能直观的感受到是流畅的。出现掉帧也就是一秒钟内刷新频率少于 60 帧，一帧耗时 1000/60 = 16.67ms，也就是说在原本 60 帧的渲染过程中，有几帧的执行耗时超过了 16.67 ms。

那么探究重点当然要归于一帧中的渲染过程，以及我们从中能学到些什么。

### 时间切片原理

由于一帧渲染过程中的 js 操作属于业务型代码，要优化耗时操作可以由业务方手动优化 js 代码。

假设 1 千次简单的 DOM 操作耗时在 16.67ms内，那么业务方将 1万次 DOM 操作用 setTimeout 分 10 次才不会出现掉帧，这样也能达到优化目的。

还有一种办法是由系统调度，因为很多时候并不是每一帧的耗时都是满满的 16.67 ms，或者说根本没有视图更新，不需要触发帧的渲染，这个时候完全可以用来调度执行那些耗时的视图更新。

时间切片技术就是使用了 `requestIdleCallback` 空闲调度函数来实现。

```js
/*
 * didTimeout {boolean} 回调是否由 timeout 参数时间到了正在被执行
 * timeRemaining {() => number} 用来获取当前一帧范围内剩余空闲时间的毫秒数
 * timeout {number} 用来指定回调的超时时间
 */
requestIdleCallback(({ didTimeout, timeRemaining() }) => {}, { timeout })
```

### 一帧的渲染过程

上面所述的 1 万次更新 DOM 的操作，我简单的说利用 setTimeout 可以分 10 次，是否可以认为：一帧就是一次 macro 调度？答案是否定的。

一帧的渲染过程

1. 处理用户的事件，在页面渲染的过程中，有可能会触发点击、输入、滚动等事件
2. macro、micro 事件循环处理
3. requestAnimationFrame 将视图更新操作放在下一帧中执行，避免在当前帧中更新视图时，导致反复重排重绘
4. parse html、layout、paint、composite 等
5. requestIdleCallback 空闲调度

> 关于浏览器一帧渲染的详细过程我暂未考证

从上可以看出 1、2、3、5 都是处理回调，将回调函数放到相应的队列中等待系统调度处理，第 4 步才是视图更新的真实操作，那么耗时的 js 操作很有可能是在第 4 步产生。

当然，如果认为 `<script></script>` 标签也是 macro 的话，那么 parse html 也应该包含此操作。

也就是说，在一帧渲染过程中，执行同步的 js 代码时长不能超过 16.67ms，实际1、2、3、5步，包括系统调度都需要耗时，严格来讲是没有 16.67ms 可用的，有可能只有 10ms 的时间。







